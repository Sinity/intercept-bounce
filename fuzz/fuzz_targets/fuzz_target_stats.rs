#![no_main]

use arbitrary::{Arbitrary, Unstructured};
use input_linux_sys::input_event;
use intercept_bounce::{config::Config, filter::stats::StatsCollector, logger::EventInfo};
use libfuzzer_sys::fuzz_target;
use std::time::Duration;

// Define a struct that can be generated by `arbitrary`
#[derive(Arbitrary, Debug)]
struct ArbitraryEventData {
    // EventInfo fields
    event_type: u16,
    event_code: u16,
    event_value: i32,
    event_us: u64,
    is_bounce: bool,
    diff_us_present: bool, // Control if diff_us is Some or None
    diff_us_value: u64,
    last_passed_us_present: bool, // Control if last_passed_us is Some or None
    last_passed_us_value: u64,
    // Config fields relevant to stats recording
    debounce_ms: u64,
    near_miss_ms: u64,
}

fuzz_target!(|data: &[u8]| {
    // Create an Unstructured instance from the raw data
    let mut u = Unstructured::new(data);

    // Generate ArbitraryEventData using the Unstructured instance
    let arb_data = match ArbitraryEventData::arbitrary(&mut u) {
        Ok(d) => d,
        Err(_) => return, // Not enough data or invalid data for arbitrary generation
    };

    // Create a dummy input_event using the generated arb_data
    let dummy_event = input_event {
        time: input_linux_sys::timeval {
            tv_sec: 0,
            tv_usec: 0,
        }, // Time not used by EventInfo directly
        type_: arb_data.event_type,
        code: arb_data.event_code,
        value: arb_data.event_value,
    };

    // Construct EventInfo from arbitrary data
    let event_info = EventInfo {
        event: dummy_event,
        event_us: arb_data.event_us,
        is_bounce: arb_data.is_bounce,
        diff_us: if arb_data.diff_us_present {
            Some(arb_data.diff_us_value)
        } else {
            None
        },
        last_passed_us: if arb_data.last_passed_us_present {
            Some(arb_data.last_passed_us_value)
        } else {
            None
        },
    };

    // Create a dummy Config (only debounce and near_miss thresholds are used by record_event_info_with_config)
    let config = Config::new(
        Duration::from_millis(arb_data.debounce_ms),
        Duration::from_millis(arb_data.near_miss_ms),
        Duration::ZERO, // log_interval not relevant here
        false,
        false,
        false,
        false, // other flags not relevant
        "info".to_string(),
        None, // otel_endpoint is not used by StatsCollector, provide None
    );

    // Create a StatsCollector
    let mut stats = StatsCollector::with_capacity();

    // Record the event info. This is the main target of this fuzz test.
    // We are checking for panics or crashes within this function.
    stats.record_event_info_with_config(&event_info, &config);

    // Optionally, you could add checks here to verify properties of the accumulated stats
    // For example, check counts are non-negative, timings are within reasonable bounds, etc.
    // This requires more complex assertions and might be added later.
});
